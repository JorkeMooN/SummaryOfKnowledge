# Redis知识点总结

### 1 简单介绍一下Redis，Redis简介

1. Redis是C语言开发的一个开源的（遵从BSD协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等；
2. 它是一种NoSQL（not-only sql，泛指非关系型数据库）的数据库。
3. Redis作为一个内存数据库，其有如下特点：
   - 性能优秀，数据在内存中，读写速度非常快，官网描述支持并发10W+ QPS；
   - 单进程单线程，是线程安全的，采用I/O多路复用机制、非阻塞I/O；
   - 丰富的数据类型，支持字符串（string）、散列（hash）、列表（list）、集合（set）、有序集合（sorted set/zset）等（额外可以回答HyperLogLog、Geo、Pub/Sub）；
   - 支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载；
   - 拥有主从复制、哨兵机制、高可用等策略；
   - 可以用作分布式锁；
   - 可以作为消息中间件使用，支持发布订阅。
   
   ![img](https://camo.githubusercontent.com/3031099b909e058d06f41e4257c95972888c9c18/68747470733a2f2f7777772e6c677374617469632e636f6d2f692f696d616765322f4d30312f38412f43412f43676f42356c31347258534148464d634141464b6564497a3061303837372e706e67)

### 2 Redis内部结构

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffV6bVv66Yy79ejYxouia93kT80KAvskE4JhJQWezh6XRhrg2KyFIF3DCn06mpVLsgsbFHubxoCT8A/640?wx_fmt=jpeg" alt="img" style="zoom: 67%;" />

- 首先redis内部使用一个redisObject对象来表示所有的key和value；
- redisObject最主要的信息如上图所示：type字段表示一个value对象具体是何种数据类型，encoding字段是不同数据类型在redis内部的存储方式，vm字段只有打开了 Redis 的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。
- 比如：type=string表示value存储的是一个普通字符串，那么encoding可以是raw或者int。

### 3 Redis的五种基本数据结构

1. string是redis最基本的类型，可以理解成与memcached一模一样的类型，一个key对应一个value。value不仅是string，也可以是数字。string类型是二进制安全的，意思是redis的string类型可以包含任何数据，比如jpg图片或者序列化的对象。string类型的值最大能存储512M。
2. hash是一个键值（key-value）的集合。redis的hash是一个string的key和value的映射表，Hash特别适合存储对象。常用命令：hget,hset,hgetall等。
3. list列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）  常用命令：lpush、rpush、lpop、rpop、lrange(获取列表片段)等。应用场景：list应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表都可以用list结构来实现。数据结构：list就是链表，可以用来当消息队列用。redis提供了List的push和pop操作，还提供了操作某一段的api，可以直接查询或者删除某一段的元素。实现方式：redis list的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。
4. set是string类型的无序集合。集合是通过hashtable实现的。set中的元素是没有顺序的，而且是没有重复的。常用命令：sdd、spop、smembers、sunion等。应用场景：redis set对外提供的功能和list一样是一个列表，特殊之处在于set是自动去重的，而且set提供了判断某个成员是否在一个set集合中。
5. zset和set一样是string类型元素的集合，且不允许重复的元素。常用命令：zadd、zrange、zrem、zcard等。使用场景：sorted set可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set结构。和set相比，sorted set关联了一个double类型权重的参数score，使得集合中的元素能够按照score进行有序排列，redis正是通过分数来为集合中的成员进行从小到大的排序。实现方式：Redis sorted set的内部使用HashMap和跳跃表(skipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

### 4 五种数据类型的应用场景

| 类型                   | 简介                                                    | 特性                                                         | 场景                                                         |
| :--------------------- | :------------------------------------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| string（字符串）       | 二进制安全                                              | 可以包含任何数据，比如jpg图片或者序列化对象                  | ---                                                          |
| hash（字典）           | 键值对集合，即编程语言中的map类型                       | 适合存储对象，并且可以像数据库中的update一个属性一样只修改某一项属性值 | 存储、读取、修改用户属性                                     |
| list（列表）           | 链表（双向链表）                                        | 增删快，提供了操作某一元素的api                              | 最新消息排行；消息队列                                       |
| set（集合）            | hashtable实现，元素不重复                               | 添加、删除、查找的复杂度都是O(1)，提供了求交集、并集、差集的操作 | 共同好友；利用唯一性，统计访问网站的所有Ip                   |
| sorted set（有序集合） | 将set中的元素增加一个权重参数score，元素按score有序排列 | 数据插入集合时，已经进行了天然排序                           | 排行榜；带权重的消息队列（延时消息队列，score存放触发时间，**zrangebyscore**） |

### 5 Redis和Memcached的区别

1. 存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。
2. 数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。
3. 使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
4. value的大小：redis可以达到1GB，而memcache只有1MB；
5. Redis有主从同步机制，Memcached没有；
6. Redis原生支持集群模式。在 redis3.x 版本中，便能支持 **Cluster** 模式，而 **Memcached** 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；
7. 性能对比：由于 **Redis** 只使用单核，而 **Memcached** 可以使用多核，所以平均每一个核上 **Redis** 在存储小数据时比 **Memcached** 性能更高。而在 100k 以上的数据中，**Memcached** 性能要高于 **Redis**，虽然 **Redis** 最近也在存储大数据的性能上进行优化，但是比起 **Memcached**，还是稍有逊色。

#### Memcache

注意后面会把 **Memcache** 简称为 MC。

先来看看 MC 的特点：

- MC 处理请求时使用**多线程异步 IO** 的方式，可以合理利用 CPU 多核的优势，性能非常优秀；
- MC 功能简单，使用内存存储数据；
- <u>MC 的内存结构以及钙化问题我就不细说了，大家可以查看[官网](http://www.memcached.org/about)了解下</u>；
- MC 对缓存的数据可以设置失效期，过期后的数据会被清除；
- 失效的策略采用**延迟失效**，就是当再次使用数据时检查是否失效；
- 当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。

另外，使用 MC 有一些限制，这些限制在现在的互联网场景下很致命，成为大家选择**Redis**、**MongoDB**的重要原因：

- key 不能超过 250 个字节；
- value 不能超过 1M ；
- key 的最大失效时间是 30 天；
- 只支持 K-V 结构，不提供持久化和主从同步功能。

### 6 Redis为什么使用单线程

Redis是单进程单线程模型，因为Redis完全是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。

原因有 2 个：一个是因为采用了非阻塞的异步事件处理机制；另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。

### 7 Redis为何这么快

1. Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O(1)。
2. 数据结构简单，对数据操作也简单。
3. 采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。
4. 使用I/O多路复用模型，非阻塞I/O。

### 8 Redis缓存雪崩

### 9 Redis缓存穿透

### 10 Redis缓存击穿

### 11 Redis淘汰策略

| 策略            | 描述                                                         |
| :-------------- | :----------------------------------------------------------- |
| volatile-lru    | 从已设置过期时间的KV集中优先对最近最少使用(less recently used)的数据淘汰 |
| volatile-ttl    | 从已设置过期时间的KV集中优先对剩余时间短(time to live)的数据淘汰 |
| volatile-random | 从已设置过期时间的KV集中随机选择数据淘汰                     |
| allkeys-lru     | 从所有KV集中优先对最近最少使用(less recently used)的数据淘汰 |
| allKeys-random  | 从所有KV集中随机选择数据淘汰                                 |
| noeviction      | 不淘汰策略，若超过最大内存，返回错误信息                     |

补充一下：Redis 4.0加入了LFU(least frequency use)淘汰策略，包括volatile-lfu和allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的KV淘汰。

### 12 Redis持久化

Redis持久化有两种策略：快照模式（RDB）和AOF。

- RDB

1. Redis在持久化时会调用glibc的函数fork产生一个子进程，快照持久化完全交给子进程来处理；
2. 子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中的一个二进制文件（dump.rdb）；
3. 需要说一句的是，这步是使用操作系统的COW（Copy On Write）机制来进行数据段页面的分离，复制一份出来，让子进程进行持久化；
4. 子进程完成写临时文件后，将原来的RDB文件替换掉；
5. 父进程不一样，它必须持续服务客户端的请求，然后对内存数据结构进行不间断的修改。

补充：内存快照要求Redis必须进行文件IO操作，可文件IO操作是不能使用多路复用API的。

- AOF

1. 存储的是Redis服务器的顺序指令序列，AOF日志只记录对内存进行修改的指令记录。
2. 先执行指令，若成功才将日志存盘，追加到appendonly.aof中。
3. appendfsync参数

| 参数值   | 效果                                                         |
| :------- | :----------------------------------------------------------- |
| no       | 不会有fsync调用，由操作系统自动调度刷磁盘，性能是最好的，但是不安全 |
| always   | 每次write后都会调用fsync，性能极差                           |
| everysec | 最多每隔 1s 执行一次 fsync 操作，最佳方案，也是默认方案      |

- 支持同时开启RDB和AOF

如果RDB和AOF都开启，Redis重启后，默认优先使用AOF来恢复数据，因为AOF的数据更加完整。

- 混合持久化

Redis 4.0带来了新的持久化选项，将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。

### 13 主从复制的连接过程

1. 从节点执行slaveof[masterIP]，保存主节点信息；
2. 从节点中的定时任务发现主节点信息，建立和主节点的socket连接；
3. 从节点发送Ping信号，主节点返回Pong，两边能互相通信；
4. 连接建立后，主节点将所有数据发送给从节点（数据同步）；
5. 主节点把当前的数据同步给从节点后，便完成了复制的建立过程；
6. 接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。

### 14 主从复制的数据同步过程

Redis 2.8之前使用sync [runId] [offset]同步命令，Redis 2.8之后使用psync [runId] [offset]命令。两者不同在于，sync命令仅支持全量复制过程，psync支持全量和部分复制。

参数（概念）介绍：

- runId：每个redis节点启动都会生成唯一的uuid，每次redis重启后，runId都会发生变化。

- offset：主节点和从节点都各自维护自己的主从复制偏移量offset，当主节点有写入命令时，offset=offset+命令的字节长度。从节点在收到主节点发送的命令后，也会增加自己的offset，并把自己的offset发送给主节点。这样，主节点同时保存自己的offset和从节点的offset，通过对比offset来判断主从节点数据是否一致。

- [repl_backlog]: https://www.cnblogs.com/aquester/p/10978366.html	"Redis主从复制之repl_backlog"

  ：是Redis用于存储更新命令的一块buffer（复制缓冲区），repl_backlog在redis启动的时候初始化为NULL，当有Slave连接上来的时候，会由主节点创建和维护一个buffer。节点只有一个repl_backlog，所有从节点共享。

  **该buffer是一个定长的环形数组（队列），如果数组内容超过buffer的大小，就会从头开始覆盖前面的内容。**

  repl_backlog只针对部分复制（Partial Replication），而非全量复制。

- repl_backlog_size：环形缓冲复制队列（复制缓冲区）的大小，默认是1MB。

- repl_backlog_ttl：环形缓冲复制队列存活时长（所有slaves不可用时，保留repl_backlog多长时间，单位：秒），默认是3600秒（1小时）。

数据同步简要过程：

1. 从节点向主节点发送psync命令，触发复制（全量or部分）；
2. 主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中；
3. 从节点同步主节点数据完成后，主节点将缓冲区的数据继续发送给从节点，用于部分复制；
4. 主节点响应写命令时，不但会把命名发送给从节点，写到从节点连接缓冲区，还会写入复制缓冲区，用于复制命令丢失的数据补救。

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffV6bVv66Yy79ejYxouia93kg1ZhKMANJOKcKhQIWZEicfBOLBftS0RyooMMHFPWaoZCgBzdgM4XByw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:80%;" />

上面是psync的执行流程：从节点发送psync [runId] [offset]命令，主节点有三种响应：（1）+FULLRESYNC：第一次连接，进行全量复制 ；（2）+CONTINUE：进行部分复制 ；（3）-ERR：不支持psync命令，进行全量复制。

### 15 全量复制和部分复制的过程

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffV6bVv66Yy79ejYxouia93knibJszjq6tDve9UnO0LRmib7281SgnyJQlvzzbCzkMCKcQ1BVCQ3z2UA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom: 80%;" />

**全量复制：**

1. 从节点发送 `psync ? -1` 命令（因为第一次发送，不知道主节点的runId，所以为?，因为是第一次复制，所以offset=-1）；
2. 主节点发现从节点是第一次复制，返回FULLRESYNC {runId} {offset}，runId是主节点的runId，offset是主节点目前的offset；
3. 从节点接收主节点信息后，保存到info中；
4. 主节点在发送FULLRESYNC后，启动bgsave命令，生成rdb文件（数据持久化）；
5. 主节点发送rdb文件给从节点，到从节点加载数据完成这段期间主节点的写命令放入复制缓冲区（repl_backlog）；
6. 从节点清空自己的数据库数据；
7. 从节点加载rdb文件，将数据保存到自己的数据库中；
8. 从节点载入rdb文件完成后通知主节点，主节点将复制缓冲区中的数据发送给从节点，进行增量更新（如果从节点开启了AOF，从节点会异步重写AOF文件）；
9. 之后主从进行命令传播。

**部分复制：**

1. 部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施，使用psync [runId] [offset]命令实现。当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，主节点的复制缓冲区将这部分数据直接发送给从节点，这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据。
2. 主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制缓冲区依然可以保存最近一段时间的写命令数据。
3. 当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量offset和主节点的runId。因此会把它们当做psync参数发送给主节点，要求进行部分复制。
4. 主节点接收到psync命令后首先核对参数runId是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数offset在复制缓冲区中查找，如果offset之后的数据存在，则对从节点发送+COUTINUE命令，表示可以进行部分复制。
5. 主节点根据偏移量把复制缓冲区里的数据发送给从节点，保证主从复制进入正常状态。
6. 因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制。

### 16 触发全量复制的场景

1. 从节点首次加入到集群中；
2. 从节点宕机后恢复时，从节点之前复制的主节点和现在的主节点不一致；
3. 从节点宕机恢复后，从节点的offset偏移量在主节点的复制积压缓冲区已经不存在。

### 17 无盘复制

Redis 2.8.18 开始支持。主节点在进行快照同步时，会进行很重的文件IO操作。为了应对这些情况，有了无盘复制。

概念：指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一边将序列化的内容发送到从节点，从节点还是跟之前一样，先将接收到的内容存储到磁盘文件中，再进行一次性加载。

### 18 主从复制会存在哪些问题

1. 一旦主节点宕机，从节点晋升为主节点，同时需要修改应用客户端的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预；
2. 主节点的写能力受到单机的限制；
3. 主节点的存储能力受到单机的限制；
4. 原生复制的弊端在早期的版本中也会比较突出，比如：redis复制中断后，从节点会发起psync。此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。

**比较主流的解决方案 -> 哨兵**

### 19 哨兵有哪些功能

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffV6bVv66Yy79ejYxouia93kKlgBX08NKiaE66ibbyqGbd6JOpjjkAMibx9rUkAzWYFqNGD2G3YicPec2Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom: 75%;" />

Redis Sentinel（哨兵）主要功能包括主节点存活检测、主从运行情况检测、自动故障转移、主从切换。Redis Sentinel最小配置是**一主一从**。Redis的Sentinel系统可以用来管理多个Redis服务器，该系统可以执行以下四个任务：

1. 监控：不断检查主服务器和从服务器是否正常运行。
2. 通知：当被监控的某个redis服务器出现问题，Sentinel通过API脚本向管理员或者其他应用程序发出通知。
3. 自动故障转移：当主节点不能正常工作时，Sentinel会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。
4. 配置提供者：在Redis Sentinel模式下，客户端应用在初始化时连接的是Sentinel节点集合，从中获取主节点的信息。

### 20 哨兵的工作原理

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/JdLkEI9sZffV6bVv66Yy79ejYxouia93kGRxNXoibsgBwe2p9AVFBicy0J6MKzrcYWb4ma43KVwoBdRLCx566D8Pg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom:67%;" />

1. 每个Sentinel节点都需要定期执行以下任务：每个Sentinel以每秒一次的频率，向它所知的主服务器、从服务器以及其他的Sentinel实例发送一个PING命令。
2. 如果一个实例距离最后一次有效回复PING命令的时间超过down-after-milliseconds所指定的值，那么这个实例会被Sentinel标记为主观下线。
3. 如果一个主服务器被标记为主观下线，那么正在监视这个服务器的所有Sentinel节点，要以每秒一次的频率确认主服务器的确进入了主观下线状态。
4. 如果一个主服务器被标记为主观下线，并且有足够数量的Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。
5. 一般情况下，每个Sentinel会以每10秒一次的频率向它已知的所有主服务器和从服务器发送INFO命令，当一个主服务器被标记为客观下线时，Sentinel向下线主服务器的所有从服务器发送INFO命令的频率，会从10秒一次改为每秒一次。
6. Sentinel和其他Sentinel协商客观下线的主节点的状态，如果处于SDOWN状态，则投票自动选出新的主节点，将剩余从节点指向新的主节点进行数据复制。
7. 当没有足够数量的Sentinel同意主服务器下线时，主服务器的客观下线状态就会被移除。当主服务器重新向Sentinel的PING命令返回有效回复时，主服务器的主观下线状态就会被移除。

### 21 Redis集群



### 22 Redis的高级用法

#### Bitmap :

位图是支持按 bit 位来存储信息，可以用来实现 **布隆过滤器（BloomFilter）**；

#### HyperLogLog:

供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；

#### Geospatial:

可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？

这三个其实也可以算作一种数据结构，不知道还有多少朋友记得，我在梦开始的地方，Redis基础中提到过，你如果只知道五种基础类型那只能拿60分，如果你能讲出高级用法，那就觉得你**有点东西**。

#### pub/sub：

功能是订阅发布功能，可以用作简单的消息队列。

#### Pipeline：

可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。

#### Lua：

**Redis** 支持提交 **Lua** 脚本来执行一系列的功能。

我在前电商老东家的时候，秒杀场景经常使用这个东西，讲道理有点香，利用他的原子性。

话说你们想看秒杀的设计么？我记得我面试好像每次都问啊，想看的直接**点赞**后评论秒杀吧。

#### 事务：

最后一个功能是事务，但 **Redis** 提供的不是严格的事务，**Redis** 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。

### 23 高可用

Redis 支持主从同步，提供 Cluster 集群部署模式，通过 Sentine l哨兵来监控 Redis 主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 slaveof 到新主。

**选主节点的策略**简单来说有三个：

- slave 的 priority 设置的越低，优先级越高；
- 同等情况下，slave 复制的数据越多优先级越高；
- 相同的条件下 runid 越小越容易被选中。

在 Redis 集群中，sentinel 也会进行多实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。

Redis Cluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。

### 24 缓存常见问题

#### 缓存更新方式

这是决定在使用缓存时就该考虑的问题。

缓存的数据在数据源发生变更时需要对缓存进行更新，数据源可能是 DB，也可能是远程服务。更新的方式可以是主动更新。数据源是 DB 时，可以在更新完 DB 后就直接更新缓存。

当数据源不是 DB 而是其他远程服务，可能无法及时主动感知数据变更，这种情况下一般会选择对缓存数据设置失效期，也就是数据不一致的最大容忍时间。

这种场景下，可以选择失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。

但这样做有个问题，如果依赖的远程服务在更新时出现异常，则会导致数据不可用。改进的办法是异步更新，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。这样就避免了失效瞬间的空窗期。另外还有一种纯异步更新方式，定时对数据进行分批更新。实际使用时可以根据业务场景选择更新方式。

#### 数据不一致

第二个问题是数据不一致的问题，可以说只要使用缓存，就要考虑如何面对这个问题。缓存不一致产生的原因一般是主动更新失败，例如更新 DB 后，更新 **Redis** 因为网络原因请求超时；或者是异步更新失败导致。

解决的办法是，如果服务对耗时不是特别敏感可以增加重试；如果服务对耗时敏感可以通过异步补偿任务来处理失败的更新，或者短期的数据不一致不会影响业务，那么只要下次更新时可以成功，能保证最终一致性就可以。



# 面试题

### 1 Redis为什么是key-value存储？

可扩展性强。

大互联网应用：RDBMS在解决大数据量时通常采用垂直和水平切割并集群部署的方式，但是这种处理方式设计到业务性太强，不同业务、应用的切割方式都不同。而key-value的存储格式的扩展性在应对这种大数据量时，只需要多加几台机器即可。

云存储：如果说上一个问题还有可以替代的解决方案（切割数据库）的话，那么对于云存储来说，也许key-value 的store就是唯一的解决方案了。客户多，业务复杂，使用RDBMS的话扩展性太差，并且并发量不高。

### 2 Redis为什么不是支持SQL的？

### 3 Redis是多线程还是单线程？

单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求；

其他模块仍然使用了多线程。例如Redis进行持久化的时候会调用 glibc 的函数 fork 产生一个子进程，快照持久化完全交给子进程来处理。

### 4 额外：多线程 vs 多进程

- 多线程之间堆内存共享，而进程相互独立，线程间通信可以直接基于共享内存来实现，比进程的常用的那些多进程通信方式更轻量。
- 在上下文切换来说，不管是多线程还是都进程都涉及到寄存器、栈的保存，但是线程不需要切换 页面映射（虚拟内存空间）、文件描述符等，所以线程的上下文切换也比多进程轻量
- 多进程比多线程更安全，一个进程基本上不会影响另外一个进程
  在实际的开发中，一般不同任务间（可以把一个线程、进程叫做一个任务）需要通信，使用多线程的场景比多进程多。但是多进程有更高的容错性，一个进程的crash不会导致整个系统的崩溃，在任务安全性较高的情况下，采用多进程。

### 5 Redis如果做集群该如何规划？AKF/CAP如何实现和设计？

### 6 10万用户一年365天的登录情况如何用redis存储，并快速检索任意时间窗内的活跃用户？

### 7 redis的5种Value类型你用过几种，能举例吗？

### 8 100万并发4G数据，10万并发400G数据，如何设计Redis存储方式？

### 9 最经典的缓存+数据库读写的模式是什么？

最经典的缓存+数据库读写的模式，就是 **Cache Aside Pattern**

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。

### 为什么是删除缓存，而不是更新缓存？

很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。对于**比较复杂的缓存数据计算的场景**，该缓存数据如果并不是那么热点的数据，那么1分钟内修改了100次，但是该缓存1分钟内只被读取了1次，那每次修改都更新缓存是得不偿失的。

其实删除缓存，而不是更新缓存，就是一个 Lazy 计算的思想（**懒加载思想**），不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。

### 10 在集群模式下，Redis 的 Key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 Hash 算法吗？

### 11 MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？

### 12 在什么样的场景下可以充分的利用Redis的特性，大大提高Redis的效率？

### 13 为什么 redis 单线程却能支撑高并发？

### 14 如何保证缓存和数据库数据的一致性？

### 15 项目中是怎么用缓存的，用了缓存之后会带来什么问题？

### 16 缓存有哪些类型？

缓存是高并发场景下提高热点数据访问性能的一个有效手段，在开发项目时会经常使用到。

缓存的类型分为：**本地缓存**、**分布式缓存**和**多级缓存**。

#### 本地缓存：

**本地缓存**就是在进程的内存中进行缓存，比如我们的 **JVM** 堆中，可以用 **LRUMap** 来实现，也可以使用 **Ehcache** 这样的工具来实现。

本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。

#### 分布式缓存：

**分布式缓存**可以很好得解决这个问题。

分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存。

#### 多级缓存：

为了平衡这种情况，实际业务中一般采用**多级缓存**，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。

在目前的一线大厂中，这也是最常用的缓存方案，单考单一的缓存方案往往难以撑住很多高并发的场景。

### 17 缓存知识点

![img](https://camo.githubusercontent.com/d55730a1a858d2508bf307b3e3893c528bc7a55b/68747470733a2f2f7777772e6c677374617469632e636f6d2f692f696d616765322f4d30312f38412f43412f43676f42356c31347258534157566b374141466469364c7938694d3134382e706e67)

### 18 淘汰策略

不管是本地缓存还是分布式缓存，为了保证较高性能，都是使用内存来保存数据，由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。

一般的剔除策略有 **FIFO** 淘汰最早数据、**LRU** 剔除最近最少使用、和 **LFU** 剔除最近使用频率最低的数据几种策略。

Redis的淘汰策略见 [Redis知识点总结-11 Redis淘汰策略]




























